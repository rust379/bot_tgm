Дисклеймер с хабра для начала
> Вы можете делать всё что угодно, выполнять любые команды, ставить эксперименты, удалять, менять. Главное не делайте git push.
> Только эта команда передаёт изменения в другой репозиторий. Только так можно что-то сломать.

## Как получить локальную копию репозитория себе
`git clone https://github.com/rust379/bot_tgm.git`
(Сам создаст папку bot_tgm, в которой будут все файлы)
Если гит настроен, то он поймет, что репозиторий ваш и сам все сделает
Для проверки можно написать git status после клонирования
Он должен сказать мол все совпадает с master, локальных изменений нет

Тут сразу можно настроить чтобы локальные изменения отслеживались относительно вашей ветки, а не мастера
`git checkout -b `local_branch_name` origin/<remote_branch_name>`
Оно создаст ветку local_branch_name и эта ветка будет отслеживаться относительно ветки remote_branch_name на гитхабе
Например git checkout -b strizh78 origin/strizh78

## Как локально что-то делать
### Пишем код и коммитим
Для того чтобы локально поменять файл - просто меняем его в любой удобной IDE :)
После внесения изменений можно их закоммитить (коммит будет локальный)
`git commit -m "text of commit"`

_Текст коммита_ это примерно 3-7 слов кратко описывающих изменения. Если изменений несколько то лучше после каждого делать отдельный коммит. Если уже все потеряно и изменения идут вместе то пишем максимально кратко про каждое важное, разделяя ';'. 

Предпочтительно на английском языке (времена соблюдать необязательно, главное чтобы мысль была ясна. Например всякие Adding file читаются хуже, чем Add file, а смысл не особо искажен получается

### Дополнительно могут пригодиться
`git status` - выводит информацию о локальном состоянии отслеживаемых файлов 
Статусы файлов:
' ' = unmodified
M = modified
A = added
D = deleted
R = renamed
C = copied
U = updated but unmerged (не уверена что это значит, скорее всего что вы изменили файл забыв принять изменения)

`git add` - добавляет новые файлы под контроль гита, можно задавать regexp вместо имени файла

аналогично есть`git move/git remove` и т д, можно погуглить

`git log` - история изменений

## Отправка изменений в гитхаб
Тут будет 2 пути

- Вариант 1 для людей которым все же проще смотреть на красивые картинки, чем на командную строку

- Вариант 2 для любителей белого текста на черном фоне и ненавидящих ревью, но он сложный и мне надо с ним разбираться, так что предположим, что его не существует)

### Как гит мержит файлы
Для начала немного информации о том как гит понимает куда засунуть ваши изменения в общий репозиторий

Предположим у нас нет своей ветки и мы самоотверженно кидаем сразу в мастер
Репозитории и внешне и локально имеют свою историю коммитов - это некий граф, его можно сбрасывать или откатывать к какому-то моменту (rebase и checkout <commit_id>)
Есть разные утилиты для просмотра этого графа в виде красивой картинки

предположим у мастера сейчас граф выглядит вот так

**master = c0 ->c1 -> c2 -> c3** [c3 сейчас является последним коммитом этой ветки и называется HEAD]

а наши локальные изменения это 

**local = c0 ->c1 -> c2 -> c3 ->c4 -> с5**

В таком случае гит просто добавит в граф мастера наши коммиты сверху
Никаких конфликтов, никаких проблем

Если случилась беда и кто-то ужасно злобный закоммитил в мастер раньше, чем мы

То есть графы сейчас выглядят так:

**master = c0 ->c1 -> c2 -> c3 -> c4**

**local = c0 ->c1 -> c2 -> c3 ->c5 -> с6**

То есть 2 варианта развития событий
1. если c4 не пересекается с с5 и с6 (они не изменяют одни и те же строки кода), то гит все спокойно смержит. Ему не сложно
2. Если с4 пересекается с с5 или с6, то гит не поймет какие изменения считать самыми актуальными для этой строки и умрет
В таком случае надо будет решать конфликт лично

Итак, это была попытка обьяснить зачем нам каждому свои ветки
Без вашего ведома в вашу ветку не придет злой дядя и не накоммитит вам гадостей всяких

### Заливка изменений для варианта 1
#### Заливка в собственную ветку
Когда мы написали весь код и протестировали делаем команду
`git push origin <your remote branch name>` - эта команда отправит все КОММИТЫ, которые вы сделали в вашу ветку на гитхабе
Все незакоммиченные изменения не отправятся

#### Заливка в мастер
Теперь идем на гитхаб https://github.com/rust379/bot_tgm
Тут есть кнопка 'New pull request' - нажимаем ее и выбираем из какой ветки в какую мы передаем изменения (base должно быть master, compare - имя нашей ветки)
Подтверждаем создание пул-реквеста (это надо сделать 2 раза, пока не появится подобное окошко)
<img width="1166" alt="Снимок экрана 2020-04-21 в 14 00 40" src="https://user-images.githubusercontent.com/38105548/79858729-8b367d00-83d8-11ea-9138-d2b0b60e0910.png">

#### Resolve conflicts
Если вы сделали пул реквест и на главной странице написано что-то типа "Не могу автоматически объединить, есть конфликты" только на английском, то не пугаемся, нажимаем "Resolve conflicts" или какая там есть кнопка с таким же именем
Он перекинет нас на файлы с кодом
Желтым будут выделены части требующие человеческого вмешательства
Выглядит как то так
```
<<<< <your_branch_name> 
(код который в этом месте у вас был локально)
========
>>>> master
(код который в этом месте в мастере)
==========
```
или картиночкой:

<img width="319" alt="Снимок экрана 2020-04-22 в 15 30 12" src="https://user-images.githubusercontent.com/38105548/80017707-accd5c80-84dd-11ea-9193-738c8818a968.png">
Тут был пул реквест из ветки beta2 в ветку master, где менялись местами строки

Убираем строки с >>>, <<<< и ====
Совмещаем код (просто удаляем ненужное, правим остальное, если надо. Можно хоть 1000 строк еще добавить, гиту надо просто чтобы вы убрали строки с >>> и ====, а оставшийся код он будет считать тем, что надо поставить на это место при одобрении пул-реквеста)

Повторить со всеми конфликтами во всех файлах, где они нашлись
Готово, вы восхитительны

#### После одобрения ревью
Нажимаем на страничке пул реквеста merge pull-request
Подтверждаем merge
Теперь наши изменения в мастере

Можно после каждого пул реквеста удалять свою ветку и создавать новую для следующей задачи

Или просто сделать пул-реквест ИЗ мастера К себе в ветку 

И **независимо от вашего выбора** в локальном репозитории сделать

`git pull (тут аналогично с git push можно уточнить ветку из которой скачивать изменения)`
~~(это надо, чтобы ваша ветка не отставала от мастера сильно, иначе с каждым разом надо будет все больше конфликтов решать)~~
И работать дальше

### Ревью пул-реквеста 
#### Заполнение информацией
Теперь мы находимся на страничке с пул-реквестом

На вкладке `commits` есть список коммитов, которые мы будем заливать

На вкладке `files` можно посмотреть разницу между текущим состоянием мастера и новым кодом (красивый построчный дифф - удобно смотреть). На этой вкладке бегло просматриваем код - вдруг что забыли сделать

Возвращаемся на вкладку `conversation`, добавляем краткое имя коммита, добавляем описание при необходимости, сбоку добавляем кого-нибудь в ревьюеры (можно сразу всех!)

Еще сбоку можно добавить задачу, которую вы решили/решаете в linked issues - с этой штукой есть проблема - сразу после закрытия пул реквеста задача закроется автоматически. Если вы еще не все доделали - переоткройте ее

Теперь ждем пока кто-то из ревьюеров не поставит "ок" или не напишут комментарии что надо исправить

> Если изменения минорные (например поставили пропущенный пробел/ поменяли порядок строк), то можно без ревью. Наверное в будущем, когда основная архитектура уже построится, то можно будет код в свои функции и без ревью проводить

#### Как провести ревью на гитхабе
Если вас призовут в ревьюеры, то вам придет уведомление на почту

[Вот тут](https://github.com/rust379/bot_tgm/pulls) в том числе видны все текущие пул-реквесты, можно отсортировать только те, где вы ревьюер

Переходите на нужный пул-реквест, там есть вся нужная информация: в lined issues есть задача, чтобы было проще проверять, на вкладке files видите код

Если хотите прокомментировать код, то наводим на него мышкой -> нажимаем появившийся '+' и пишем комментарий.
После написания всех текущих комментариев идем в conversation, нажимаем еще раз start review
Человек сможет ответить на ваши комментарии или отметить конфликт решенным, если переделал как вы хотите

### Откат кода
Если вам просто надо что-то переделать в ревью, то проще сделать это поверх текущих коммитов

Если же все таки откат, то надо узнать номер коммита на который надо откатить
сделать `git rebase` текущей ветки на этот коммит или удалить текущую и сделать `git checkout` для новой и начинать работать с этого коммита

Откатить мастер вроде немного сложнее так что давайте не будем)

Дисклеймер2: 
> Я никогда не занималась откатом, так что если придется этим заниматься, то давайте потом допишем сюда подробнее

## Issue
На гитхабе на страничке репозитория есть вкладка issue (задачи)

Дисклеймер3:
> Далее issue я буду называть тасками, тикетами или задачами

У тикета можно сразу указать исполнителя или оставить поле пустым
Там же можно указать label, чтобы мы знали к чему это относится

На страничке с тикетами можно фильтровать их по разным критериям, в том числе по исполнителю
К пул реквесту можно прилинковать тикет и он **автоматически закроется** с ссылкой на коммит

#### Предлагаются такие правила работы
- Каждый может создать тикет с предложениями по улучшению/доработке/багом с label='suggestion' (при этом можно не становится его исполнителем)
При создании желательно сразу в описании написать подробности/ полезные ссылки и другую штуку
- Раз в N времени смотрим тикеты с таким лейблом и решаем хотим мы это делать или нет
Если нет - закрываем тикет, если да - убираем лейбл и пусть тикет дальше висит в очереди
- Если человек хочет, то может назначить себя исполнителем любого незанятого тикета
- Если вы решаете большую задачу, то можно разбить ее на более мелкие, создав соответсвующие issue
(допишите если я чего забыла)

Дисклеймер4 [последний]: 
> Данные  неполные, тут только то с чем я много или немного сталкивалась. 

[Официальные доки гитхаба по гиту](https://help.github.com/en/github/using-git)
